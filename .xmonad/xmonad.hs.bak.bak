aoeu
-- TODO move X stuff from .xinitirc and also add xrandr
-- TODO key to switch dvorak and qwerty
-- TODO .xinitrc move most of to here?

-- TODO disable those wretches dropbox popups!
-- TODO binding for keepass
--
-- TODO SIGCHLD

import Control.Applicative
import qualified Data.Map as M
import qualified Data.Set as S
import System.Exit

import XMonad
import XMonad.Hooks.EmergencyHooks
import XMonad.Hooks.ManageDocks
import XMonad.Layout.NoBorders
import XMonad.Layout.ResizableTile
import XMonad.Layout.Tabbed
import XMonad.Layout.WindowNavigation

--- MAIN CONFIGURATIOn ---

main = xmonad . withUrgencyHookC urgencyHook urgency $ defaultConfig
    { normalBorderColor  = unfocusedColor
    , focusedBorderColor = focusedColor
    , terminal           = "urxvt"  -- terminal needs to support -title option or modify the m-s-return key binding to behave properly; I suggest installing, configuring, and using urxvt
    , layoutHook         = windowNavigation . avoidStruts $ layouts
    , manageHook         = manage
    , handleEventHook    = event
    , workspaces         =
        [
        -- '`'-9 (qwerty)
        , "Background"
        , "Programming 1"
        , "Status"
        , "Empty"
        , "IRC"
        , "Media"  -- music, web browsing, etc.
        , "Programming 2"
        , "Graphics 1"  -- primarily gimp
        , "Private 1"
        , "Administration"
    , numlockMask        = mod2Mask
    , modMask            = mod4Mask
    , keys               = keyBindings
    , mouseBindings      = mouse
    , borderWidth        = 1
    , logHook            = log
    , startupHook        = startup
    , focusFollowsMouse  = True
    }

focusedColor, unfocusedColor, urgentColor :: String
focusedColor   = "#121262"
unfocusedColor = "#12122F"
urgentColor    = "#4212CC"

--- STARTUP ---
startup :: X ()
startup = do
    undefined error --TODO

--- URGENCY ---
urgency = urgencyConfig
    { suppressWhen = Focused--Never
    , remindWhen   = Every 120  -- seconds
    }

--- WINDOW MANAGING ---
manage :: ManageHook
manage = composeAll $
    [ manageDocks

    -- Windows to automatically float
    --, className =? "MPlayer"          --> doFloat
    , className =? "Gimp"             --> doFloat
    , className =? "Thunar"           --> doFloat
    , className =? "VLC media player" --> doFloat
    , className =? "Xcfe4-panel"      --> doFloat
    , className =? "Xfce-mcs-manager" --> doFloat
    , className =? "Xcfe-mixer"       --> doFloat
    , className =? "Gui.py"           --> doFloat

    -- Windows to ignore
    , resource  =? "gnome_panel"      --> doIgnore
    , resource  =? "desktop_window"   --> doIgnore

    -- Windows to move to a workspace
    , title     =? "Navigator"        --> doShift "Media"
    , title     =? "Namoroka"         --> doShift "Media"
    , title     =? "Vimperator"       --> doShift "Media"
    , title     =? "Iceweasel"        --> doShift "Media"
    , title     =? "IRC"              --> doShift "IRC"
    , className =? "Gimp"             --> doShift "Graphics 1"
    ]

--- LOG HOOK ---
log :: X ()
log = ewmhDesktopsLogHook

--- EVENT HOOK ---
event :: Event -> X All
event = mempty

--- MOUSE ---
mouse (XConfig {XMonad.modMask = modm}) = M.fromList $
    -- mod-button1; set the window to floating mode and move by dragging
    [ ((modm, button1), (\w -> focus w >> mouseMoveWindow w
                                       >> windows W.shiftMaster))
 
    -- mod-button2; raise the window to the top of the stack
    , ((modm, button2), (\w -> focus w >> windows W.shiftMaster))
 
    -- mod-button3; set the window to floating mode and resize by dragging
    , ((modm, button3), (\w -> focus w >> mouseResizeWindow w
                                       >> windows W.shiftMaster))
 
    -- you may also bind events to the mouse scroll wheel (button4 and button5)
    ]

--- LAYOUTS ---

layouts :: (LayoutClass l a) => l a
-- Feel free to add your own.  Check out XMonad.Layout.* at http://hackage.haskell.org/package/xmonad-contrib-0.9.1 (the newest version, of course) and see http://hackage.haskell.org/packages/archive/xmonad-contrib/latest/doc/html/XMonad-Doc-Extending.html#Editing_the_layout_hook.
layouts = windowNavigation . avoidStruts $ smartBorders (noBorders (customTabbed) ||| Full ||| tall ||| Mirror tall ||| Circle)
    where tall = ResizableTall 1 (3.0 / 100.0) (1.0 / 2.0) []
          customTabbed = shrinkText $ defaultTheme
              { inactiveBorderColor = white
              , activeBorderColor   = focusedColor
              , urgentBorderColor   = urgentColor
              , inactiveTextColor   = grey
              , activeTextColor     = white
              , urgentTextColor     = white
              , inactiveColor       = unfocusedColor
              , activeColor         = focusedColor
              , urgentColor         = urgentColor
              , decoHeight          = 8
              , fontName            = "-*-terminus-*-*-*-*-8-*-*-*-*-*-iso10646-1"
              }

--- KEYS ---

keyBindings :: XConfig Layout -> M.Map (ButtonMask, KeySym) (X ())
keyBindings config@(XConfig { modMask = modm
                            }
-- Notice that some bindings don't use the layout conversion functions.  This happens when the key is a mnemonic for its function (instead of its positioning being important) and its position will never be inconvenient or conflict with another position.
myKeys conf@(XConfig {modMask = modm}) = M.fromList $
    -- XMonad --
    -- quit
    , ((modm .|. shiftMask, xK_q), io $ exitWith ExitSuccess)

    -- Window Navigation --

    -- arrow keys
    [ ((modm, xK_Right), sendMessage $ Go R)
    , ((modm, xK_Left ), sendMessage $ Go L)
    , ((modm, xK_Up   ), sendMessage $ Go U)
    , ((modm, xK_Down ), sendMessage $ Go D)

    , ((modm .|. shiftMask, xK_Right), sendMessage $ Swap R)
    , ((modm .|. shiftMask, xK_Left ), sendMessage $ Swap L)
    , ((modm .|. shiftMask, xK_Up   ), sendMessage $ Swap U)
    , ((modm .|. shiftMask, xK_Down ), sendMessage $ Swap D)                                      

    , ((modm .|. controlMask .|. shiftMask, xK_Right), sendMessage $ Move R)
    , ((modm .|. controlMask .|. shiftMask, xK_Left),  sendMessage $ Move L)
    , ((modm .|. controlMask .|. shiftMask, xK_Up),    sendMessage $ Move U)
    , ((modm .|. controlMask .|. shiftMask, xK_Down),  sendMessage $ Move D)

    -- home row
    , ((modm, toKey $ xK_k), windows $ focusUp)
    , ((modm, toKey $ xK_j), windows $ focusDown)

    , ((modm .|. shiftMask, toKey $ xK_k), windows $ swapUp)
    , ((modm .|. shiftMask, toKey $ xK_j), windows $ swapDown)

    -- tab
    , ((modm, xK_Tab),               windows focusDown)
    , ((modm .|. shiftMask, xK_Tab), windows focusUp)


    -- Layouts, master area, and arrangement of windows --

    -- shrink and expand focused window; shift does so by a greater magnitude; keys conveniently placed near backspace (on most keyboards)
    , ((modm, toKey $ xK_minus), sendMessage MirrorShrink)
    , ((modm, toKey $ xK_equal), sendMessage MirrorExpand)
    , ((modm .|. shiftMask, toKey $ xK_minus), doReplicate 4 $ sendMessage MirrorShrink)
    , ((modm .|. shiftMask, toKey $ xK_equal), doReplicate 4 $ sendMessage MirrorExpand)

    -- shrink and expand master area
    , ((modm, toKey $ xK_h), sendMessage Shrink)
    , ((modm, toKey $ xK_l), sendMessage Expand)

    -- focus the master area by focusing a window in the master area
    , ((modm, xK_m), windows focusMaster)

    -- tile the focused window; this is particularity useful for floating windows
    , ((modm, toKey $ xK_t), withFocused $ windows . sink)  -- Conveniently placed immediately after master size keys

    -- decrement or increment master area size (which is the number of windows the master area will try to contain)
    -- '<' or '>'
    , ((modm , xK_comma),  sendMessage (IncMasterN (-1)))
    , ((modm , xK_period), sendMessage (IncMasterN ( 1)))

    -- layout updates
    , ((modm, xK_space), sendMessage NextLayout)                            -- Next layout
    , ((modm .|. shiftMask, xK_space), setLayout $ XMonad.layoutHook conf)  -- Set layout to default one

    -- kill a window
    , ((modm, xK_k), kill)
    , ((modm .|. shiftMask, xK_k), spawn "xkill")


    -- Urgency --
    , ((modm, xK_Backspace), focusUrgent)
    , ((modm .|. shiftMask, xK_Backspace), clearUrgents)


    -- Misc --
    , ((modm, xK_o), "exe=`dmenu_path | dmenu` && eval \"exec $exe\"")  -- Mnemonic: open program
    , ((modm, xK_r), refresh)  -- Mnemonic: refresh
    , ((modm .|. shiftMask, xK_Return), spawn $ terminal conf ++ " -title IRC")  -- These terminals are moved to the IRC workspace
    , ((modm, xK_a), spawn $ terminal conf)
    -- increase and decrease opacity
    , ((modm , toKey $ xK_d), spawn "transset-df -a --dec .1")
    , ((modm , toKey $ xK_f), spawn "transset-df -a --inc .1")


    -- Program bindings.  This key configuration is focused on using dmenu to start programs.  dmenu is often more convenient than running "program &disown %1&&exit" in a terminal.  If you wish to still use a key binding to start a program, you can add your own bindings as shown below.
    -- example:
    -- , ((modm, xK_f), spawn "firefox")
    -- Or, if the position of the key is more important than its mnemonic or character, toKey can be used with the character on a qwerty keyboard, and the position won't change when your key layout is changed.  For example:
    -- , ((modm, toKey $ xK_a), spawn "firefox")
    ]

    ++

    -- Workspaces --

    [((m .|. modm, k), windows $ f i) | (k, i) <- zip workspaceKeys $ workspaces conf, (f, m) <- [(greedyView, 0), (shift, shiftMask)]]

    ++

    -- Screens --

    [((m .|. modm, k), screenWorkSpace s >>= flip whenJust (windows . f)) | (s, k) <- flip screenKeys [0..], (f, m) <- [(view, 0), (shift, shiftMask)]]

    where workspaceKeys, screenKeys :: [KeySym]
          workspaceKeys = toKey <$> [xK_grave] ++ [xK_1 .. xK_9]
          screenKeys    = toKey <$> [xK_y, xK_u, xK_i]

--- KEY LAYOUTS ---

keyLayout :: KeyLayout
keyLayout = programmerDvorak

toQwerty :: KeySym -> KeySym
toQwerty = toQwertyLayout keyLayout

toKey :: KeySym -> KeySym
toKey = toKeyLayout keyLayout

toQwertyLayout :: KeyLayout -> KeySym -> KeySym
toQwertyLayout kl k = let s = S.filter ((== k) . klk_toKey) $ kl_layout kl
                      in  case () of _
                              | S.null s  -> k
                              | otherwise -> klk_qwerty . head . elems $ s
toKeyLayout    :: KeyLayout -> KeySym -> KeySym
toKeyLayout    kl k = let s = S.filter ((== k) . klk_qwerty) $ kl_layout kl
                      in  case () of _
                              | S.null s  -> k
                              | otherwise -> klk_toKey . head . elems $ s

-- unionKeyLayout original append; returns append with the layout of original appended to the layout of append
unionKeyLayout :: KeyLayout -> KeyLayout -> KeyLayout
unionKeyLayout original append = KeyLayout (kl_workspaceStartsLeftmost append) $ kl_layout original `S.union` kl_layout append

newtype KeyLayout = KeyLayout { kl_layout :: S.Set KeyLayoutTrans
                              }

data KeyLayoutTrans = KeyLayoutTrans { klk_qwerty :: KeySym
                                     , klk_toKey  :: KeySym
                                     }

qwerty :: KeyLayout
qwerty = KeyLayout . S.fromList $ []

dvorak :: KeyLayout
dvorak = KeyLayout . S.fromList . map (\(q, t) -> KeyLayoutKey {klk_qwerty = q, klk_toKey = t}) $
    [ (xK_a, xK_a)
    , (xK_b, xK_x)
    , (xK_c, xK_j)
    , (xK_d, xK_e)
    , (xK_e, xK_period)
    , (xK_f, xK_u)
    , (xK_g, xK_i)
    , (xK_h, xK_d)
    , (xK_i, xK_c)
    , (xK_j, xK_h)
    , (xK_k, xK_t)
    , (xK_l, xK_n)
    , (xK_m, xK_m)
    , (xK_n, xK_b)
    , (xK_o, xK_r)
    , (xK_p, xK_l)
    , (xK_q, xK_apostrophe)
    , (xK_r, xK_p)
    , (xK_s, xK_o)
    , (xK_t, xK_y)
    , (xK_u, xK_g)
    , (xK_v, xK_k)
    , (xK_w, xK_comma)
    , (xK_x, xK_q)
    , (xK_y, xK_f)
    , (xK_z, xK_semicolon)
    , (xK_bracketleft, xK_slash)
    , (xK_bracketright, xK_equal)
    , (xK_backslash, xK_backslash)
    , (xK_slash, xK_z)
    , (xK_equal, xK_bracketright)
    , (xK_minus, xK_bracketleft)
    , (xK_apostrophe, xK_minus)
    , (xK_comma, xK_w)
    , (xK_period, xK_v)
    , (xK_semicolon, xK_s)
    ]

programmerDvorak :: KeyLayout
programmerDvorak = (dvorak `unionKeyLayout`) . KeyLayout . S.fromList . map (\(q, t) -> KeyLayoutKey {klk_qwerty = q, klk_toKey = t}) $
    [ (xK_grave,        xK_dollar)
    , (xK_1,            xK_ampersand)
    , (xK_2,            xK_bracketleft)
    , (xK_3,            xK_braceleft)
    , (xK_4,            xK_braceright)
    , (xK_5,            xK_parenleft)
    , (xK_6,            xK_equal)
    , (xK_7,            xK_asterisk)
    , (xK_8,            xK_parenright)
    , (xK_9,            xK_plus)
    , (xK_0,            xK_bracketright)
    , (xK_minus,        xK_exclam)
    , (xK_equal,        xK_numbersign)
    , (xK_bracketleft,  xK_bracketleft)
    , (xK_bracketright, xK_at)
    , (xK_backslash,    xK_backslash)
    , (xK_asciitilde,   xK_asciitilde)
    , (xK_exclam,       xK_percent)
    , (xK_at,           xK_7)
    , (xK_numbersign,   xK_5)
    , (xK_dollar,       xK_3)
    , (xK_percent,      xK_1)
    , (xK_asciicircum,  xK_9)
    , (xK_ampersand,    xK_0)
    , (xK_asterisk,     xK_2)
    , (xK_parenleft,    xK_4)
    , (xK_parenright,   xK_6)
    , (xK_underscore,   xK_8)
    , (xK_plus,         xK_grave)
    , (xK_braceleft,    xK_question)
    , (xK_braceright,   xK_asciicircum)
    , (xK_bar,          xK_bar)
    ]

--- UTILITY ---

doReplicate :: (Integral a, Monad m) => a -> m b -> m b
doReplicate n = sequence . replicate n
